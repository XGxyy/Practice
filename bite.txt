memset设置缓冲区到指定字符（开辟空间清零）、
scanf只能接受int类型返回int类型的值
冒泡排序（On^2)
指针开辟动态存储空间
const 在c中是只读的意思 cpp中是常量
const int* p   p本身是个指针指向const
int* const p   p本身是const的一个指针
break continue return (关键字退出）exit（函数退出）
开辟的动态内存不能多次释放，不为空时才能释放
开辟了动态内存如果不释放会使内存泄漏
尽量不要返回栈空间的指针
static的静态全局变量的生命周期只能在当前源文件中使用 
           静态局部变量作用域到整个工程中（用完后不释放，直到整个工程运行结束）
数据文件：文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出 内容的文件。
fopen打开一个文件，打开后必须要fclose关闭fopen（“文件名”，“读还是写（读为r，写为w）”）
fgetc读文件的一个字符内容，fputc写一个字符到文件中去
fgets读文件的字符串（num中包含‘\0')，fputs写字符串到文件中
fscanf格式化读取文件内容，fprintf格式化打印到文件中去
fread二进制输出，fwrite二进制输入：fread(buf, size, num, fp);//size是一次读的个数，num是读的次数,它的返回值是正确读的次数。
EOF文件结束标志
sprintf(a,"%d",a)把a的类型直接打印到a中以%d形式输出（格式化输入输出sprintf和sscanf）
do {break}while(0) 置标签的值 可以代替goto的弊端
一个不可重入函数必须要加锁（输入输出类都是不可重入的）
存在的文件才能读，但是不存在的文件也可以写只不过是在创建一个新的文件去写，写的内容会覆盖上一次的内容，所以要再加东西要用a的方式打开
以“r"或“w”方式打开指针指向文件的开头
rewind函数 将当前指针回到开头位置
fseek（移动一个文件类型指针到指定位置去）：int fseek ( FILE * stream, long int offset, int origin );把stream指针挪动到距离origin处offset距离处
ftell（返回文件指针相对于起始位置的偏移量）
SEEK_SET表示0（开头）位置，SEEK_表示1（当前）SEEK_表示2（末尾在最后一个字符后面）
_stat 在文件中获得一些信息（要用头文件#include<sys/stat.h>
feof（文件结束判断**最好不用**）在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。
perror判断文件是否存在问题反馈
ferror判断文件结束的原因
全部都是字符串的话，对于所有都可以部分类型使用并可见，若有非字符类（格式化）用fread和fwrite是不可见的乱码 其他的不影响
预处理定义：1.宏定义 （#define N(宏名) 10(值)） 2.
##可以把位于它两边的符号合成一个符号。 它允许宏定义从分离的文本片段创建标识符。
为什么不用函数来完成这个任务？ 原因有二{
	1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程 序的规模和速度方面更胜一筹
	2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎 可以适用于整形、长整型、浮点型等可以用于>来比较的类型。宏是类型无关的。
}
头文件的包含如果是“”是先在本工程目录中找，找不到再去标准库函数路径去找，而<>直接去标准路径去找