OO（面向对象）语言三大特性：继承，封装，多态系统函数存放在std中 cout是一个输出流，自动检测类型
并输出 endl是一个换行流 cin是一个输入流

**名字空间（namespace）：
0.可以解决函数或全局变量名重复的问题
1.可以嵌套使用，嵌套的内外部没有任何关系
2.同名名字空间编译时会默认合并（允许重名）
3.包在不同名字空间中的重复函数实际是互不相关的两个函数
（ps：它的本质是用来定义作用域的，解决了c中只能用文件划分作用域的缺陷）
（pps：双冒号(::)可以声名调用的域）

使用using关键字，可以引用一个名字空间，使其内容对自己可见
如果两个名字空间分别有相同的两个函数，那么即使同时using应用两个名字空间那么也不会报错，除非我使用
函数

**函数重载和缺省函数
0.缺省函数的参数可以在形参处直接连续赋值，调用时可以不写实参a.若未传参，则使用形参被赋的值b.若传参，
则用传进的参数
1.重载函数：可以名字一样但是参数（类型）不能相同
例如：int Add(int left, int right) { 
	return left+right; 
	}	
double Add(double left, double right) { 
	return left+right;
	 }
ps：函数重载的前提是参数列表不同(参数类型数量等等）

**名字修饰：
在C语言中，名字修饰只是在函数名前加下划线，所以只要函数名字相同，就会冲突
而C++中，名字修饰是由"?函数名@域名1@域名2...@@参数列表@Z"的格式构成
例题：C++中函数重载底层是怎么处理的？
            c++在名字修饰时会加上他的域名和参数列表

*extern"C"    使用它修饰语句可以让编译时以C的格式(规则)编译语句

**引用（底层的实现实际是指针）
0.引用是代替指针跨栈操作的，它具备指针的一切特点
1. 引用在定义时必须初始化 
2. 一个变量可以有多个引用 
3. 引用一旦引用一个实体(变量)，再不能引用其他实体(变量）
4.做参数时，相当于修改被引用变量的值
5.返回一个局部变量的引用时(返回值是一个引用)，若引用函数被多次调用则理论上最后的值是一个不确定的随机值
例如: int& Add(int a,int b){
	int c = a + b;
	return c;
	}
          int main(){
	int& rc = Add(1, 2);
	Add(3, 4);
	cout << "Add(1, 2) is :"<< ret <<endl; 
	return 0;
	}(结果是 7)

引用和指针的不同点:
1. 引用在定义时必须初始化，指针没有要求
2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
3. 没有NULL引用，但有NULL指针 
4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4 个字节) 
5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小 
6. 有多级指针，但是没有多级引用 
!7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理 
!8. 引用比指针使用起来相对!更安全!

**内联函数(本质是用来提升效率的)
调用时不创建新栈，而直接在调用处展开的函数较内联函数，关键字是inline
内联函数是一个对编译器的建议，如果函数过于复杂，编译器会不接受你的建议

auto修饰的变量可以根据它被赋的值的类型选择自己变量的类型(自动类型)
auto可以连续定义变量，类型由第一个定义的变量决定，后续不能违背这个类型

for(auto i : arr)  适用于遍历全部arr数组的内容
for(auto& i : arr) 用引用访问或改变arr数组的全部内容

nullptr使用注意：
1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。
2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。
3. 为了提高代码的健壮性，在后续表示指针空值时建议好使用nullptr。

**类和对象
一.结构体
结构体的内存大小向最大的看齐，但如果前两个相加都达不到最大的呢么这两个一起向最大看齐

C与C++的结构体的不同:
1.在c++中，用结构体定义变量不需要加struct，c不行
2.c++中，可以定义空结构体大小为1，c不行
3.c++中，可以在结构体中声名或实现函数，c中只能放函数指针
4.c++中，成员函数中可以直接使用自己的成员变量无需传入，c中函数与结构并无直接关联
例如:struct S{
	int a;
	void print(){
		printf("%d", a);
	}
}//输出的a就是自己结构体中定义的a
所以c++中的struct是一个!域(简化版的类)

二.类
class className {   
public：//给全局可用的权限
 	// 类体：由成员函数和成员变量组成 
};  // 一定要注意后面的分号
它是一类特殊的结构体如上述使用方法就与结构体的使用方法一样

访问限定符：
public：正常访问
private：只能在类中访问
protected：类似private

tip1：访问限定符只在编译阶段生效，编译好后，运行阶段并没有限定
tip2：结构体中也能用访问限定符
tip3：结构体中默认是public，而类中默认是private

三.this指针
1.一般成员函数中都含有一个this指针，这个指针指向调用这个成员函数的对象
2.成员函数中，this指针调用时不需要写this->（this根据类的类型走，即类类型* const）
3.this指针存在子函数（成员函数）的栈中的临时变量
ps：在函数最后方加const就可以保护this指针不被改动

C++代码规则：
全局变量g_  局部静态变量s_  成员变量m_
引用和const修饰的变量必须初始化

**变量初始化
狭义初始化：在定义变量时直接进行初始化
int a = 3;
广义初始化：第一次给变量赋值就叫做初始化的情况
int a ;
.....//与a无关的代码
a = 3;

初始化列表相当于狭义初始化，而构造函数内部相当于广义初始化
所以初始化列表可以解决一些只能用狭义初始化进行初始化的变量，例如：
const变量
引用
没有无参构造的类的对象

explicit：阻止单参构造的不规范调用
单参函数的构造函数，可以用=直接调用
例如：
假设CT类中有一个单参数构造函数，参数类型为int或int相关的类型，
那么“CT a = 3;“这种写法是被允许的但是别扭，看上去好像直接把
3赋给了a，为了避免这种写法，可以在构造函数加explicit，使这种写法无效 

类的6个默认成员函数
一.构造函数
1.只要创建类，系统会自动生成一个空的构造函数，若自己实现，则系统将不再提供
2.一旦类被创建(实例化对象)，就调用它，它没有(不存在)返回值
3.构造函数可以重载,可以存在参数
写法：①poker(参数(可以不写)): m_type(0){}
          ②poker(参数(可以不写)){
	m_type = 0;
	}

二..拷贝构造函数:系统会自动生成，可以拷贝类中已有数据(浅拷贝)
深拷贝需要自己写(必须要传引用,防止无限递归)

三.析构函数
1. 析构函数名是在类名前加上字符 ~ 
2. 无参数无返回值
3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数
4. 对象生命周期结束时，C++编译系统系统自动调用析构函数
5.当一个栈结束或被销毁之前，在最后会对每一个对象执行析构函数(如果没写就执行空)

四.（取地址）赋值运算符重载函数
将运算符重看成函数，把他的几目当成参数，通过参数的类型识别出对应的操作方法，相当于函数重载555
    ~不能通过连接其他符号来创建新的操作符：比如operator@
    ~重载操作符必须有一个类类型或者枚举类型的操作数 
    ~用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义 
赋值运算符主要有四点：
1. 参数类型 2. 返回值 3. 检测是否自己给自己赋值 4. 返回*this 5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。
 
**类的静态成员（static）
不属于某个对象，属于整个类
1.静态成员变量：①所有对象共享，他不占类中的空间，可以不用对象进行调用（直接用：：调用）
            	          ②必须在外面初始化对象，初始化时不加前缀
2静态成员函数：其中不能访问其他普通成员（因为他的默认参数没有this指针）需要传参，
                         但可以直接访问静态成员变量